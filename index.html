<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>RepoVerse Explorer üåå</title>
<style>
  body { margin:0; background:#111; font-family:sans-serif; color:white; overflow:hidden;}
  canvas { display:block; }
  #controls { position:absolute; top:10px; left:10px; z-index:10; }
  input, button { padding:5px; border-radius:4px; border:none; margin-bottom:5px; cursor:pointer; }
  #infoBox {
    position:absolute; top:10px; right:10px; background:rgba(20,20,20,0.9);
    padding:15px; border-radius:8px; width:300px; display:none; z-index:10;
  }
</style>
</head>
<body>

<div id="controls">
  <input id="username" placeholder="GitHub Username / Org">
  <input id="token" type="password" placeholder="GitHub PAT (optional)">
  <button id="loadUser">Load User/Org</button>
  <button id="loadUniverse">Load All Repos Universe</button>
</div>

<div id="infoBox"></div>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let planets = [];
let zoomScale = 1;
let offsetX = 0;
let offsetY = 0;
const zoomFactor = 0.1;

const infoBox = document.getElementById('infoBox');

function languageToColor(lang) {
  switch(lang){
    case "JavaScript": return "#f1e05a";
    case "C#": return "#178600";
    case "C": return "#a8b9cc";
    case "Python": return "#3572A5";
    case "HTML": return "#e34c26";
    default: return "#888";
  }
}

// API fetch with optional PAT
async function apiFetch(url){
  const token = document.getElementById('token').value.trim();
  const headers = token ? { Authorization: 'token ' + token } : {};
  const res = await fetch(url, { headers });
  if(!res.ok) throw new Error(`API Error: ${res.status}`);
  return await res.json();
}

// Fetch repos
async function fetchRepos(username){
  try{
    return await apiFetch(`https://api.github.com/users/${username}/repos?per_page=50`);
  } catch(e){ alert(e.message); return []; }
}

// Fetch org members
async function fetchOrgMembers(org){
  try{
    return await apiFetch(`https://api.github.com/orgs/${org}/members?per_page=50`);
  } catch(e){ return []; }
}

// Fetch universe slice
async function fetchReposSlice(page=1){
  try{
    const data = await apiFetch(`https://api.github.com/search/repositories?q=created:>2025-01-01&sort=updated&order=desc&per_page=50&page=${page}`);
    return data.items || [];
  } catch(e){ return []; }
}

// Build planets with topic clusters & fork moons
function buildUniverse(repos, startX=100, startY=100){
  planets = [];
  const topicsMap = {};
  repos.forEach(repo=>{
    const topic = repo.topics && repo.topics[0] ? repo.topics[0] : "none";
    if(!topicsMap[topic]) topicsMap[topic] = [];
    topicsMap[topic].push(repo);
  });

  let clusterIndex = 0;
  const clusterSpacing = 300;
  for(const topic in topicsMap){
    const clusterRepos = topicsMap[topic];
    clusterRepos.forEach((repo,i)=>{
      const cx = startX + clusterIndex*clusterSpacing + (i%5)*60;
      const cy = startY + Math.floor(i/5)*60;
      planets.push({
        x: cx,
        y: cy,
        size: Math.log(repo.stargazers_count + 5),
        color: languageToColor(repo.language),
        repo: repo,
        moons: repo.forks_count ? Math.min(repo.forks_count,5) : 0
      });
    });
    clusterIndex++;
  }
  draw();
}

// Draw planets + moons
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  planets.forEach(p=>{
    ctx.beginPath();
    ctx.arc(p.x*zoomScale + offsetX, p.y*zoomScale + offsetY, p.size*zoomScale, 0, Math.PI*2);
    ctx.fillStyle = p.color;
    ctx.fill();
    // moons
    for(let m=0;m<p.moons;m++){
      const angle = (m/p.moons)*2*Math.PI;
      const r = p.size + 5;
      const mx = p.x + Math.cos(angle)*r;
      const my = p.y + Math.sin(angle)*r;
      ctx.beginPath();
      ctx.arc(mx*zoomScale + offsetX, my*zoomScale + offsetY, 3*zoomScale,0,Math.PI*2);
      ctx.fillStyle = "#aaa";
      ctx.fill();
    }
  });
}

// Click planet
canvas.addEventListener('click', e=>{
  const mx = (e.clientX - offsetX)/zoomScale;
  const my = (e.clientY - offsetY)/zoomScale;
  for(let p of planets){
    const dx = mx - p.x;
    const dy = my - p.y;
    if(Math.sqrt(dx*dx + dy*dy) <= p.size){
      showRepoInfo(p.repo);
      return;
    }
  }
});

function showRepoInfo(repo){
  infoBox.style.display = 'block';
  infoBox.innerHTML = `
    <h2>${repo.name}</h2>
    <p>${repo.description || "No description"}</p>
    <p>‚≠ê Stars: ${repo.stargazers_count}</p>
    <p>üç¥ Forks: ${repo.forks_count}</p>
    <p>üí¨ Language: ${repo.language || "N/A"}</p>
    <p>üìù Topics: ${repo.topics && repo.topics.length ? repo.topics.join(', ') : "None"}</p>
    <a href="${repo.html_url}" target="_blank">üîó Visit Repo</a>
  `;
}

// Zoom
canvas.addEventListener('wheel', e=>{
  e.preventDefault();
  const mx = e.clientX;
  const my = e.clientY;
  const dir = e.deltaY < 0 ? 1 : -1;
  const factor = 1 + zoomFactor*dir;
  offsetX = mx - factor*(mx - offsetX);
  offsetY = my - factor*(my - offsetY);
  zoomScale *= factor;
  draw();
});

// Drag
let isDragging=false, dragStart={x:0,y:0};
canvas.addEventListener('mousedown', e=>{isDragging=true; dragStart={x:e.clientX-offsetX, y:e.clientY-offsetY}});
canvas.addEventListener('mousemove', e=>{if(isDragging){offsetX=e.clientX-dragStart.x; offsetY=e.clientY-dragStart.y; draw();}});
canvas.addEventListener('mouseup', ()=>{isDragging=false});
canvas.addEventListener('mouseleave', ()=>{isDragging=false});

// Load user/org
document.getElementById('loadUser').addEventListener('click', async ()=>{
  const input = document.getElementById('username').value.trim();
  if(!input) return;
  planets = [];
  let members = await fetchOrgMembers(input);
  if(members.length>0){
    const spacing = 300;
    for(let i=0;i<members.length;i++){
      const member = members[i];
      const repos = await fetchRepos(member.login);
      buildUniverse(repos, 50 + (i%5)*spacing, 50 + Math.floor(i/5)*spacing);
    }
  } else {
    const repos = await fetchRepos(input);
    buildUniverse(repos, canvas.width/2-100, canvas.height/2-100);
  }
});

// Load All Repos Universe
document.getElementById('loadUniverse').addEventListener('click', async ()=>{
  let allRepos = [];
  for(let page=1; page<=5; page++){
    const slice = await fetchReposSlice(page);
    allRepos = allRepos.concat(slice);
  }
  buildUniverse(allRepos);
});

// Resize
window.addEventListener('resize', ()=>{
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  draw();
});
</script>

</body>
</html>
