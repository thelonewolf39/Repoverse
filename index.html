<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>RepoVerse Universe üåå</title>
<style>
  body { margin:0; background:#111; font-family:sans-serif; color:white; overflow:hidden;}
  canvas { display:block; }
  #controls { position:absolute; top:10px; left:10px; z-index:10; }
  button { padding:5px; border-radius:4px; border:none; margin-bottom:5px; cursor:pointer; }
  #infoBox {
    position:absolute; top:10px; right:10px; background:rgba(20,20,20,0.9);
    padding:15px; border-radius:8px; width:300px; display:none; z-index:10;
  }
</style>
</head>
<body>

<div id="controls">
  <button id="loadUniverse">Load All Repos Universe</button>
</div>

<div id="infoBox"></div>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let planets = [];
let zoomScale = 1;
let offsetX = 0;
let offsetY = 0;
const zoomFactor = 0.1;

const infoBox = document.getElementById('infoBox');

function languageToColor(lang) {
  switch(lang){
    case "JavaScript": return "#f1e05a";
    case "C#": return "#178600";
    case "C": return "#a8b9cc";
    case "Python": return "#3572A5";
    case "HTML": return "#e34c26";
    default: return "#888";
  }
}

// Fetch repos slice
async function fetchReposSlice(page=1){
  try{
    const res = await fetch(`https://api.github.com/search/repositories?q=created:>2025-01-01&sort=updated&order=desc&per_page=50&page=${page}`);
    const data = await res.json();
    return data.items || [];
  } catch(e){ return []; }
}

// Build planets with topic clusters
function buildUniverse(repos){
  planets = [];
  const topicsMap = {};
  repos.forEach((repo,i)=>{
    const topic = repo.topics && repo.topics[0] ? repo.topics[0] : "none";
    if(!topicsMap[topic]) topicsMap[topic] = [];
    topicsMap[topic].push(repo);
  });

  let clusterIndex = 0;
  const clusterSpacing = 300;
  for(const topic in topicsMap){
    const clusterRepos = topicsMap[topic];
    clusterRepos.forEach((repo,i)=>{
      const cx = 100 + clusterIndex*clusterSpacing + (i%5)*60;
      const cy = 100 + Math.floor(i/5)*60;
      planets.push({
        x: cx,
        y: cy,
        size: Math.log(repo.stargazers_count + 5),
        color: languageToColor(repo.language),
        repo: repo,
        moons: repo.forks_count ? Math.min(repo.forks_count, 5) : 0 // max 5 moons
      });
    });
    clusterIndex++;
  }
  draw();
}

// Draw planets + moons
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  planets.forEach(p=>{
    // Planet
    ctx.beginPath();
    ctx.arc(p.x*zoomScale + offsetX, p.y*zoomScale + offsetY, p.size*zoomScale, 0, Math.PI*2);
    ctx.fillStyle = p.color;
    ctx.fill();
    // Moons (forks)
    for(let m=0;m<p.moons;m++){
      const angle = (m/p.moons)*2*Math.PI;
      const r = p.size + 5;
      const mx = p.x + Math.cos(angle)*r;
      const my = p.y + Math.sin(angle)*r;
      ctx.beginPath();
      ctx.arc(mx*zoomScale + offsetX, my*zoomScale + offsetY, 3*zoomScale,0,Math.PI*2);
      ctx.fillStyle = "#aaa";
      ctx.fill();
    }
  });
}

// Click planet for info
canvas.addEventListener('click', e=>{
  const mx = (e.clientX - offsetX)/zoomScale;
  const my = (e.clientY - offsetY)/zoomScale;
  for(let p of planets){
    const dx = mx - p.x;
    const dy = my - p.y;
    if(Math.sqrt(dx*dx+dy*dy) <= p.size){
      showRepoInfo(p.repo);
      return;
    }
  }
});

function showRepoInfo(repo){
  infoBox.style.display = 'block';
  infoBox.innerHTML = `
    <h2>${repo.name}</h2>
    <p>${repo.description || "No description"}</p>
    <p>‚≠ê Stars: ${repo.stargazers_count}</p>
    <p>üç¥ Forks: ${repo.forks_count}</p>
    <p>üí¨ Language: ${repo.language || "N/A"}</p>
    <p>üìù Topics: ${repo.topics && repo.topics.length ? repo.topics.join(', ') : "None"}</p>
    <a href="${repo.html_url}" target="_blank">üîó Visit Repo</a>
  `;
}

// Mouse wheel zoom
canvas.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const mx = e.clientX;
  const my = e.clientY;
  const dir = e.deltaY < 0 ? 1 : -1;
  const factor = 1 + zoomFactor*dir;
  offsetX = mx - factor*(mx - offsetX);
  offsetY = my - factor*(my - offsetY);
  zoomScale *= factor;
  draw();
});

// Drag pan
let isDragging = false;
let dragStart = {x:0,y:0};
canvas.addEventListener('mousedown', e=>{isDragging=true; dragStart={x:e.clientX - offsetX, y:e.clientY - offsetY}});
canvas.addEventListener('mousemove', e=>{if(isDragging){offsetX = e.clientX - dragStart.x; offsetY = e.clientY - dragStart.y; draw();}});
canvas.addEventListener('mouseup', ()=>{isDragging=false});
canvas.addEventListener('mouseleave', ()=>{isDragging=false});

// Load universe
document.getElementById('loadUniverse').addEventListener('click', async ()=>{
  let allRepos = [];
  for(let page=1; page<=5; page++){ // 5*50=250 repos
    const slice = await fetchReposSlice(page);
    allRepos = allRepos.concat(slice);
  }
  buildUniverse(allRepos);
});

// Resize
window.addEventListener('resize', ()=>{
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  draw();
});
</script>
</body>
</html>
